// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SFPacketStore.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SFPacketStore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SFPacketStore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SFPacketStore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SFPacketStore_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[34]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SFPacketStore_2eproto;
namespace SFPacketStore {
class ADD_PEER;
class ADD_PEERDefaultTypeInternal;
extern ADD_PEERDefaultTypeInternal _ADD_PEER_default_instance_;
class ChangeTeam;
class ChangeTeamDefaultTypeInternal;
extern ChangeTeamDefaultTypeInternal _ChangeTeam_default_instance_;
class ChatReq;
class ChatReqDefaultTypeInternal;
extern ChatReqDefaultTypeInternal _ChatReq_default_instance_;
class ChatRes;
class ChatResDefaultTypeInternal;
extern ChatResDefaultTypeInternal _ChatRes_default_instance_;
class CreateRoom;
class CreateRoomDefaultTypeInternal;
extern CreateRoomDefaultTypeInternal _CreateRoom_default_instance_;
class DELETE_PEER;
class DELETE_PEERDefaultTypeInternal;
extern DELETE_PEERDefaultTypeInternal _DELETE_PEER_default_instance_;
class EnterLobby;
class EnterLobbyDefaultTypeInternal;
extern EnterLobbyDefaultTypeInternal _EnterLobby_default_instance_;
class EnterRoom;
class EnterRoomDefaultTypeInternal;
extern EnterRoomDefaultTypeInternal _EnterRoom_default_instance_;
class EnterTeamMember;
class EnterTeamMemberDefaultTypeInternal;
extern EnterTeamMemberDefaultTypeInternal _EnterTeamMember_default_instance_;
class InvalidPacket;
class InvalidPacketDefaultTypeInternal;
extern InvalidPacketDefaultTypeInternal _InvalidPacket_default_instance_;
class LeaveRoom;
class LeaveRoomDefaultTypeInternal;
extern LeaveRoomDefaultTypeInternal _LeaveRoom_default_instance_;
class LeaveTeamMember;
class LeaveTeamMemberDefaultTypeInternal;
extern LeaveTeamMemberDefaultTypeInternal _LeaveTeamMember_default_instance_;
class LoadingComplete;
class LoadingCompleteDefaultTypeInternal;
extern LoadingCompleteDefaultTypeInternal _LoadingComplete_default_instance_;
class LoadingStart;
class LoadingStartDefaultTypeInternal;
extern LoadingStartDefaultTypeInternal _LoadingStart_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class LoginFail;
class LoginFailDefaultTypeInternal;
extern LoginFailDefaultTypeInternal _LoginFail_default_instance_;
class LoginSuccess;
class LoginSuccessDefaultTypeInternal;
extern LoginSuccessDefaultTypeInternal _LoginSuccess_default_instance_;
class MSG_CREATE_PLAYER;
class MSG_CREATE_PLAYERDefaultTypeInternal;
extern MSG_CREATE_PLAYERDefaultTypeInternal _MSG_CREATE_PLAYER_default_instance_;
class MSG_DESTROY_PLAYER;
class MSG_DESTROY_PLAYERDefaultTypeInternal;
extern MSG_DESTROY_PLAYERDefaultTypeInternal _MSG_DESTROY_PLAYER_default_instance_;
class PLAYER_IP;
class PLAYER_IPDefaultTypeInternal;
extern PLAYER_IPDefaultTypeInternal _PLAYER_IP_default_instance_;
class PeerList;
class PeerListDefaultTypeInternal;
extern PeerListDefaultTypeInternal _PeerList_default_instance_;
class PeerList_PeerInfo;
class PeerList_PeerInfoDefaultTypeInternal;
extern PeerList_PeerInfoDefaultTypeInternal _PeerList_PeerInfo_default_instance_;
class PlayEnd;
class PlayEndDefaultTypeInternal;
extern PlayEndDefaultTypeInternal _PlayEnd_default_instance_;
class PlayMove;
class PlayMoveDefaultTypeInternal;
extern PlayMoveDefaultTypeInternal _PlayMove_default_instance_;
class PlayPlayerScore;
class PlayPlayerScoreDefaultTypeInternal;
extern PlayPlayerScoreDefaultTypeInternal _PlayPlayerScore_default_instance_;
class PlayScoreInfo;
class PlayScoreInfoDefaultTypeInternal;
extern PlayScoreInfoDefaultTypeInternal _PlayScoreInfo_default_instance_;
class PlayStart;
class PlayStartDefaultTypeInternal;
extern PlayStartDefaultTypeInternal _PlayStart_default_instance_;
class RoomList;
class RoomListDefaultTypeInternal;
extern RoomListDefaultTypeInternal _RoomList_default_instance_;
class RoomListRefresh;
class RoomListRefreshDefaultTypeInternal;
extern RoomListRefreshDefaultTypeInternal _RoomListRefresh_default_instance_;
class RoomList_RoomInfo;
class RoomList_RoomInfoDefaultTypeInternal;
extern RoomList_RoomInfoDefaultTypeInternal _RoomList_RoomInfo_default_instance_;
class RoomMember;
class RoomMemberDefaultTypeInternal;
extern RoomMemberDefaultTypeInternal _RoomMember_default_instance_;
class RoomMember_Member;
class RoomMember_MemberDefaultTypeInternal;
extern RoomMember_MemberDefaultTypeInternal _RoomMember_Member_default_instance_;
class TeamInfo;
class TeamInfoDefaultTypeInternal;
extern TeamInfoDefaultTypeInternal _TeamInfo_default_instance_;
class TeamInfo_TeamMember;
class TeamInfo_TeamMemberDefaultTypeInternal;
extern TeamInfo_TeamMemberDefaultTypeInternal _TeamInfo_TeamMember_default_instance_;
}  // namespace SFPacketStore
PROTOBUF_NAMESPACE_OPEN
template<> ::SFPacketStore::ADD_PEER* Arena::CreateMaybeMessage<::SFPacketStore::ADD_PEER>(Arena*);
template<> ::SFPacketStore::ChangeTeam* Arena::CreateMaybeMessage<::SFPacketStore::ChangeTeam>(Arena*);
template<> ::SFPacketStore::ChatReq* Arena::CreateMaybeMessage<::SFPacketStore::ChatReq>(Arena*);
template<> ::SFPacketStore::ChatRes* Arena::CreateMaybeMessage<::SFPacketStore::ChatRes>(Arena*);
template<> ::SFPacketStore::CreateRoom* Arena::CreateMaybeMessage<::SFPacketStore::CreateRoom>(Arena*);
template<> ::SFPacketStore::DELETE_PEER* Arena::CreateMaybeMessage<::SFPacketStore::DELETE_PEER>(Arena*);
template<> ::SFPacketStore::EnterLobby* Arena::CreateMaybeMessage<::SFPacketStore::EnterLobby>(Arena*);
template<> ::SFPacketStore::EnterRoom* Arena::CreateMaybeMessage<::SFPacketStore::EnterRoom>(Arena*);
template<> ::SFPacketStore::EnterTeamMember* Arena::CreateMaybeMessage<::SFPacketStore::EnterTeamMember>(Arena*);
template<> ::SFPacketStore::InvalidPacket* Arena::CreateMaybeMessage<::SFPacketStore::InvalidPacket>(Arena*);
template<> ::SFPacketStore::LeaveRoom* Arena::CreateMaybeMessage<::SFPacketStore::LeaveRoom>(Arena*);
template<> ::SFPacketStore::LeaveTeamMember* Arena::CreateMaybeMessage<::SFPacketStore::LeaveTeamMember>(Arena*);
template<> ::SFPacketStore::LoadingComplete* Arena::CreateMaybeMessage<::SFPacketStore::LoadingComplete>(Arena*);
template<> ::SFPacketStore::LoadingStart* Arena::CreateMaybeMessage<::SFPacketStore::LoadingStart>(Arena*);
template<> ::SFPacketStore::Login* Arena::CreateMaybeMessage<::SFPacketStore::Login>(Arena*);
template<> ::SFPacketStore::LoginFail* Arena::CreateMaybeMessage<::SFPacketStore::LoginFail>(Arena*);
template<> ::SFPacketStore::LoginSuccess* Arena::CreateMaybeMessage<::SFPacketStore::LoginSuccess>(Arena*);
template<> ::SFPacketStore::MSG_CREATE_PLAYER* Arena::CreateMaybeMessage<::SFPacketStore::MSG_CREATE_PLAYER>(Arena*);
template<> ::SFPacketStore::MSG_DESTROY_PLAYER* Arena::CreateMaybeMessage<::SFPacketStore::MSG_DESTROY_PLAYER>(Arena*);
template<> ::SFPacketStore::PLAYER_IP* Arena::CreateMaybeMessage<::SFPacketStore::PLAYER_IP>(Arena*);
template<> ::SFPacketStore::PeerList* Arena::CreateMaybeMessage<::SFPacketStore::PeerList>(Arena*);
template<> ::SFPacketStore::PeerList_PeerInfo* Arena::CreateMaybeMessage<::SFPacketStore::PeerList_PeerInfo>(Arena*);
template<> ::SFPacketStore::PlayEnd* Arena::CreateMaybeMessage<::SFPacketStore::PlayEnd>(Arena*);
template<> ::SFPacketStore::PlayMove* Arena::CreateMaybeMessage<::SFPacketStore::PlayMove>(Arena*);
template<> ::SFPacketStore::PlayPlayerScore* Arena::CreateMaybeMessage<::SFPacketStore::PlayPlayerScore>(Arena*);
template<> ::SFPacketStore::PlayScoreInfo* Arena::CreateMaybeMessage<::SFPacketStore::PlayScoreInfo>(Arena*);
template<> ::SFPacketStore::PlayStart* Arena::CreateMaybeMessage<::SFPacketStore::PlayStart>(Arena*);
template<> ::SFPacketStore::RoomList* Arena::CreateMaybeMessage<::SFPacketStore::RoomList>(Arena*);
template<> ::SFPacketStore::RoomListRefresh* Arena::CreateMaybeMessage<::SFPacketStore::RoomListRefresh>(Arena*);
template<> ::SFPacketStore::RoomList_RoomInfo* Arena::CreateMaybeMessage<::SFPacketStore::RoomList_RoomInfo>(Arena*);
template<> ::SFPacketStore::RoomMember* Arena::CreateMaybeMessage<::SFPacketStore::RoomMember>(Arena*);
template<> ::SFPacketStore::RoomMember_Member* Arena::CreateMaybeMessage<::SFPacketStore::RoomMember_Member>(Arena*);
template<> ::SFPacketStore::TeamInfo* Arena::CreateMaybeMessage<::SFPacketStore::TeamInfo>(Arena*);
template<> ::SFPacketStore::TeamInfo_TeamMember* Arena::CreateMaybeMessage<::SFPacketStore::TeamInfo_TeamMember>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SFPacketStore {

enum TeamType : int {
  NONE = -1,
  RED = 0,
  BLUE = 1
};
bool TeamType_IsValid(int value);
constexpr TeamType TeamType_MIN = NONE;
constexpr TeamType TeamType_MAX = BLUE;
constexpr int TeamType_ARRAYSIZE = TeamType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TeamType_descriptor();
template<typename T>
inline const std::string& TeamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeamType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TeamType_descriptor(), enum_t_value);
}
inline bool TeamType_Parse(
    const std::string& name, TeamType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TeamType>(
    TeamType_descriptor(), name, value);
}
// ===================================================================

class Login :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }
  inline void Swap(Login* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const final {
    return CreateMaybeMessage<Login>(nullptr);
  }

  Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.Login";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // required string UserName = 1;
  bool has_username() const;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // required string Password = 2;
  bool has_password() const;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // @@protoc_insertion_point(class_scope:SFPacketStore.Login)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class LoginSuccess :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.LoginSuccess) */ {
 public:
  LoginSuccess();
  virtual ~LoginSuccess();

  LoginSuccess(const LoginSuccess& from);
  LoginSuccess(LoginSuccess&& from) noexcept
    : LoginSuccess() {
    *this = ::std::move(from);
  }

  inline LoginSuccess& operator=(const LoginSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginSuccess& operator=(LoginSuccess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginSuccess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginSuccess* internal_default_instance() {
    return reinterpret_cast<const LoginSuccess*>(
               &_LoginSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginSuccess& a, LoginSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginSuccess* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginSuccess* New() const final {
    return CreateMaybeMessage<LoginSuccess>(nullptr);
  }

  LoginSuccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginSuccess>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginSuccess& from);
  void MergeFrom(const LoginSuccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginSuccess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.LoginSuccess";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // required bytes UserInfo = 2;
  bool has_userinfo() const;
  void clear_userinfo();
  const std::string& userinfo() const;
  void set_userinfo(const std::string& value);
  void set_userinfo(std::string&& value);
  void set_userinfo(const char* value);
  void set_userinfo(const void* value, size_t size);
  std::string* mutable_userinfo();
  std::string* release_userinfo();
  void set_allocated_userinfo(std::string* userinfo);

  // required int32 Result = 1;
  bool has_result() const;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.LoginSuccess)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userinfo_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class LoginFail :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.LoginFail) */ {
 public:
  LoginFail();
  virtual ~LoginFail();

  LoginFail(const LoginFail& from);
  LoginFail(LoginFail&& from) noexcept
    : LoginFail() {
    *this = ::std::move(from);
  }

  inline LoginFail& operator=(const LoginFail& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginFail& operator=(LoginFail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginFail& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginFail* internal_default_instance() {
    return reinterpret_cast<const LoginFail*>(
               &_LoginFail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginFail& a, LoginFail& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginFail* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginFail* New() const final {
    return CreateMaybeMessage<LoginFail>(nullptr);
  }

  LoginFail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginFail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginFail& from);
  void MergeFrom(const LoginFail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginFail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.LoginFail";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // required int32 Result = 1;
  bool has_result() const;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.LoginFail)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class TeamInfo_TeamMember :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.TeamInfo.TeamMember) */ {
 public:
  TeamInfo_TeamMember();
  virtual ~TeamInfo_TeamMember();

  TeamInfo_TeamMember(const TeamInfo_TeamMember& from);
  TeamInfo_TeamMember(TeamInfo_TeamMember&& from) noexcept
    : TeamInfo_TeamMember() {
    *this = ::std::move(from);
  }

  inline TeamInfo_TeamMember& operator=(const TeamInfo_TeamMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeamInfo_TeamMember& operator=(TeamInfo_TeamMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TeamInfo_TeamMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TeamInfo_TeamMember* internal_default_instance() {
    return reinterpret_cast<const TeamInfo_TeamMember*>(
               &_TeamInfo_TeamMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TeamInfo_TeamMember& a, TeamInfo_TeamMember& b) {
    a.Swap(&b);
  }
  inline void Swap(TeamInfo_TeamMember* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TeamInfo_TeamMember* New() const final {
    return CreateMaybeMessage<TeamInfo_TeamMember>(nullptr);
  }

  TeamInfo_TeamMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TeamInfo_TeamMember>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TeamInfo_TeamMember& from);
  void MergeFrom(const TeamInfo_TeamMember& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeamInfo_TeamMember* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.TeamInfo.TeamMember";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 1,
  };
  // required string Member = 1;
  bool has_member() const;
  void clear_member();
  const std::string& member() const;
  void set_member(const std::string& value);
  void set_member(std::string&& value);
  void set_member(const char* value);
  void set_member(const char* value, size_t size);
  std::string* mutable_member();
  std::string* release_member();
  void set_allocated_member(std::string* member);

  // @@protoc_insertion_point(class_scope:SFPacketStore.TeamInfo.TeamMember)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr member_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class TeamInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.TeamInfo) */ {
 public:
  TeamInfo();
  virtual ~TeamInfo();

  TeamInfo(const TeamInfo& from);
  TeamInfo(TeamInfo&& from) noexcept
    : TeamInfo() {
    *this = ::std::move(from);
  }

  inline TeamInfo& operator=(const TeamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeamInfo& operator=(TeamInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TeamInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TeamInfo* internal_default_instance() {
    return reinterpret_cast<const TeamInfo*>(
               &_TeamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TeamInfo& a, TeamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TeamInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TeamInfo* New() const final {
    return CreateMaybeMessage<TeamInfo>(nullptr);
  }

  TeamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TeamInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TeamInfo& from);
  void MergeFrom(const TeamInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeamInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.TeamInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TeamInfo_TeamMember TeamMember;

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 6,
    kTypeFieldNumber = 1,
  };
  // repeated .SFPacketStore.TeamInfo.TeamMember Member = 6;
  int member_size() const;
  void clear_member();
  ::SFPacketStore::TeamInfo_TeamMember* mutable_member(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >*
      mutable_member();
  const ::SFPacketStore::TeamInfo_TeamMember& member(int index) const;
  ::SFPacketStore::TeamInfo_TeamMember* add_member();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >&
      member() const;

  // required .SFPacketStore.TeamType Type = 1 [default = RED];
  bool has_type() const;
  void clear_type();
  ::SFPacketStore::TeamType type() const;
  void set_type(::SFPacketStore::TeamType value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.TeamInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember > member_;
  int type_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class RoomMember_Member :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.RoomMember.Member) */ {
 public:
  RoomMember_Member();
  virtual ~RoomMember_Member();

  RoomMember_Member(const RoomMember_Member& from);
  RoomMember_Member(RoomMember_Member&& from) noexcept
    : RoomMember_Member() {
    *this = ::std::move(from);
  }

  inline RoomMember_Member& operator=(const RoomMember_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomMember_Member& operator=(RoomMember_Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomMember_Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomMember_Member* internal_default_instance() {
    return reinterpret_cast<const RoomMember_Member*>(
               &_RoomMember_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RoomMember_Member& a, RoomMember_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomMember_Member* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomMember_Member* New() const final {
    return CreateMaybeMessage<RoomMember_Member>(nullptr);
  }

  RoomMember_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomMember_Member>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomMember_Member& from);
  void MergeFrom(const RoomMember_Member& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomMember_Member* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.RoomMember.Member";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 1,
    kPlayerIndexFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // required string Member = 1;
  bool has_member() const;
  void clear_member();
  const std::string& member() const;
  void set_member(const std::string& value);
  void set_member(std::string&& value);
  void set_member(const char* value);
  void set_member(const char* value, size_t size);
  std::string* mutable_member();
  std::string* release_member();
  void set_allocated_member(std::string* member);

  // required int32 PlayerIndex = 2;
  bool has_playerindex() const;
  void clear_playerindex();
  ::PROTOBUF_NAMESPACE_ID::int32 playerindex() const;
  void set_playerindex(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required .SFPacketStore.TeamType Type = 3;
  bool has_type() const;
  void clear_type();
  ::SFPacketStore::TeamType type() const;
  void set_type(::SFPacketStore::TeamType value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomMember.Member)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr member_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerindex_;
  int type_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class RoomMember :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.RoomMember) */ {
 public:
  RoomMember();
  virtual ~RoomMember();

  RoomMember(const RoomMember& from);
  RoomMember(RoomMember&& from) noexcept
    : RoomMember() {
    *this = ::std::move(from);
  }

  inline RoomMember& operator=(const RoomMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomMember& operator=(RoomMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomMember* internal_default_instance() {
    return reinterpret_cast<const RoomMember*>(
               &_RoomMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RoomMember& a, RoomMember& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomMember* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomMember* New() const final {
    return CreateMaybeMessage<RoomMember>(nullptr);
  }

  RoomMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomMember>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomMember& from);
  void MergeFrom(const RoomMember& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomMember* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.RoomMember";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RoomMember_Member Member;

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 12,
  };
  // repeated .SFPacketStore.RoomMember.Member Info = 12;
  int info_size() const;
  void clear_info();
  ::SFPacketStore::RoomMember_Member* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomMember_Member >*
      mutable_info();
  const ::SFPacketStore::RoomMember_Member& info(int index) const;
  ::SFPacketStore::RoomMember_Member* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomMember_Member >&
      info() const;

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomMember)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomMember_Member > info_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class EnterTeamMember :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.EnterTeamMember) */ {
 public:
  EnterTeamMember();
  virtual ~EnterTeamMember();

  EnterTeamMember(const EnterTeamMember& from);
  EnterTeamMember(EnterTeamMember&& from) noexcept
    : EnterTeamMember() {
    *this = ::std::move(from);
  }

  inline EnterTeamMember& operator=(const EnterTeamMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterTeamMember& operator=(EnterTeamMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnterTeamMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterTeamMember* internal_default_instance() {
    return reinterpret_cast<const EnterTeamMember*>(
               &_EnterTeamMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EnterTeamMember& a, EnterTeamMember& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterTeamMember* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnterTeamMember* New() const final {
    return CreateMaybeMessage<EnterTeamMember>(nullptr);
  }

  EnterTeamMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnterTeamMember>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnterTeamMember& from);
  void MergeFrom(const EnterTeamMember& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterTeamMember* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.EnterTeamMember";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 1,
    kPlayerIndexFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // required string Member = 1;
  bool has_member() const;
  void clear_member();
  const std::string& member() const;
  void set_member(const std::string& value);
  void set_member(std::string&& value);
  void set_member(const char* value);
  void set_member(const char* value, size_t size);
  std::string* mutable_member();
  std::string* release_member();
  void set_allocated_member(std::string* member);

  // required int32 PlayerIndex = 2;
  bool has_playerindex() const;
  void clear_playerindex();
  ::PROTOBUF_NAMESPACE_ID::int32 playerindex() const;
  void set_playerindex(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required .SFPacketStore.TeamType Type = 3;
  bool has_type() const;
  void clear_type();
  ::SFPacketStore::TeamType type() const;
  void set_type(::SFPacketStore::TeamType value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.EnterTeamMember)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr member_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerindex_;
  int type_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class LeaveTeamMember :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.LeaveTeamMember) */ {
 public:
  LeaveTeamMember();
  virtual ~LeaveTeamMember();

  LeaveTeamMember(const LeaveTeamMember& from);
  LeaveTeamMember(LeaveTeamMember&& from) noexcept
    : LeaveTeamMember() {
    *this = ::std::move(from);
  }

  inline LeaveTeamMember& operator=(const LeaveTeamMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveTeamMember& operator=(LeaveTeamMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeaveTeamMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaveTeamMember* internal_default_instance() {
    return reinterpret_cast<const LeaveTeamMember*>(
               &_LeaveTeamMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LeaveTeamMember& a, LeaveTeamMember& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveTeamMember* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaveTeamMember* New() const final {
    return CreateMaybeMessage<LeaveTeamMember>(nullptr);
  }

  LeaveTeamMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaveTeamMember>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeaveTeamMember& from);
  void MergeFrom(const LeaveTeamMember& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveTeamMember* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.LeaveTeamMember";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 1,
    kPlayerIndexFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // required string Member = 1;
  bool has_member() const;
  void clear_member();
  const std::string& member() const;
  void set_member(const std::string& value);
  void set_member(std::string&& value);
  void set_member(const char* value);
  void set_member(const char* value, size_t size);
  std::string* mutable_member();
  std::string* release_member();
  void set_allocated_member(std::string* member);

  // required int32 PlayerIndex = 2;
  bool has_playerindex() const;
  void clear_playerindex();
  ::PROTOBUF_NAMESPACE_ID::int32 playerindex() const;
  void set_playerindex(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required .SFPacketStore.TeamType Type = 3;
  bool has_type() const;
  void clear_type();
  ::SFPacketStore::TeamType type() const;
  void set_type(::SFPacketStore::TeamType value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.LeaveTeamMember)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr member_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerindex_;
  int type_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class InvalidPacket :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.InvalidPacket) */ {
 public:
  InvalidPacket();
  virtual ~InvalidPacket();

  InvalidPacket(const InvalidPacket& from);
  InvalidPacket(InvalidPacket&& from) noexcept
    : InvalidPacket() {
    *this = ::std::move(from);
  }

  inline InvalidPacket& operator=(const InvalidPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvalidPacket& operator=(InvalidPacket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InvalidPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvalidPacket* internal_default_instance() {
    return reinterpret_cast<const InvalidPacket*>(
               &_InvalidPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InvalidPacket& a, InvalidPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(InvalidPacket* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvalidPacket* New() const final {
    return CreateMaybeMessage<InvalidPacket>(nullptr);
  }

  InvalidPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvalidPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InvalidPacket& from);
  void MergeFrom(const InvalidPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvalidPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.InvalidPacket";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgFieldNumber = 1,
  };
  // required string Arg = 1;
  bool has_arg() const;
  void clear_arg();
  const std::string& arg() const;
  void set_arg(const std::string& value);
  void set_arg(std::string&& value);
  void set_arg(const char* value);
  void set_arg(const char* value, size_t size);
  std::string* mutable_arg();
  std::string* release_arg();
  void set_allocated_arg(std::string* arg);

  // @@protoc_insertion_point(class_scope:SFPacketStore.InvalidPacket)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class EnterLobby :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.EnterLobby) */ {
 public:
  EnterLobby();
  virtual ~EnterLobby();

  EnterLobby(const EnterLobby& from);
  EnterLobby(EnterLobby&& from) noexcept
    : EnterLobby() {
    *this = ::std::move(from);
  }

  inline EnterLobby& operator=(const EnterLobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterLobby& operator=(EnterLobby&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnterLobby& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterLobby* internal_default_instance() {
    return reinterpret_cast<const EnterLobby*>(
               &_EnterLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EnterLobby& a, EnterLobby& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterLobby* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnterLobby* New() const final {
    return CreateMaybeMessage<EnterLobby>(nullptr);
  }

  EnterLobby* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnterLobby>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnterLobby& from);
  void MergeFrom(const EnterLobby& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterLobby* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.EnterLobby";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLobbyIndexFieldNumber = 1,
  };
  // optional int32 LobbyIndex = 1 [default = 0];
  bool has_lobbyindex() const;
  void clear_lobbyindex();
  ::PROTOBUF_NAMESPACE_ID::int32 lobbyindex() const;
  void set_lobbyindex(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.EnterLobby)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 lobbyindex_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class ChatReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.ChatReq) */ {
 public:
  ChatReq();
  virtual ~ChatReq();

  ChatReq(const ChatReq& from);
  ChatReq(ChatReq&& from) noexcept
    : ChatReq() {
    *this = ::std::move(from);
  }

  inline ChatReq& operator=(const ChatReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatReq& operator=(ChatReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChatReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatReq* internal_default_instance() {
    return reinterpret_cast<const ChatReq*>(
               &_ChatReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ChatReq& a, ChatReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChatReq* New() const final {
    return CreateMaybeMessage<ChatReq>(nullptr);
  }

  ChatReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChatReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChatReq& from);
  void MergeFrom(const ChatReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.ChatReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // required string Message = 1;
  bool has_message() const;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // @@protoc_insertion_point(class_scope:SFPacketStore.ChatReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class ChatRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.ChatRes) */ {
 public:
  ChatRes();
  virtual ~ChatRes();

  ChatRes(const ChatRes& from);
  ChatRes(ChatRes&& from) noexcept
    : ChatRes() {
    *this = ::std::move(from);
  }

  inline ChatRes& operator=(const ChatRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatRes& operator=(ChatRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChatRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatRes* internal_default_instance() {
    return reinterpret_cast<const ChatRes*>(
               &_ChatRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChatRes& a, ChatRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatRes* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChatRes* New() const final {
    return CreateMaybeMessage<ChatRes>(nullptr);
  }

  ChatRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChatRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChatRes& from);
  void MergeFrom(const ChatRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.ChatRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // required string Sender = 1;
  bool has_sender() const;
  void clear_sender();
  const std::string& sender() const;
  void set_sender(const std::string& value);
  void set_sender(std::string&& value);
  void set_sender(const char* value);
  void set_sender(const char* value, size_t size);
  std::string* mutable_sender();
  std::string* release_sender();
  void set_allocated_sender(std::string* sender);

  // required string Message = 2;
  bool has_message() const;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // @@protoc_insertion_point(class_scope:SFPacketStore.ChatRes)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class EnterRoom :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.EnterRoom) */ {
 public:
  EnterRoom();
  virtual ~EnterRoom();

  EnterRoom(const EnterRoom& from);
  EnterRoom(EnterRoom&& from) noexcept
    : EnterRoom() {
    *this = ::std::move(from);
  }

  inline EnterRoom& operator=(const EnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoom& operator=(EnterRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnterRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterRoom* internal_default_instance() {
    return reinterpret_cast<const EnterRoom*>(
               &_EnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EnterRoom& a, EnterRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoom* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnterRoom* New() const final {
    return CreateMaybeMessage<EnterRoom>(nullptr);
  }

  EnterRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnterRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnterRoom& from);
  void MergeFrom(const EnterRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.EnterRoom";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 3,
    kRoomIndexFieldNumber = 1,
    kGameModeFieldNumber = 2,
  };
  // optional string Password = 3;
  bool has_password() const;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // required int32 RoomIndex = 1;
  bool has_roomindex() const;
  void clear_roomindex();
  ::PROTOBUF_NAMESPACE_ID::int32 roomindex() const;
  void set_roomindex(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required int32 GameMode = 2;
  bool has_gamemode() const;
  void clear_gamemode();
  ::PROTOBUF_NAMESPACE_ID::int32 gamemode() const;
  void set_gamemode(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.EnterRoom)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::int32 roomindex_;
  ::PROTOBUF_NAMESPACE_ID::int32 gamemode_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class CreateRoom :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.CreateRoom) */ {
 public:
  CreateRoom();
  virtual ~CreateRoom();

  CreateRoom(const CreateRoom& from);
  CreateRoom(CreateRoom&& from) noexcept
    : CreateRoom() {
    *this = ::std::move(from);
  }

  inline CreateRoom& operator=(const CreateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoom& operator=(CreateRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoom* internal_default_instance() {
    return reinterpret_cast<const CreateRoom*>(
               &_CreateRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateRoom& a, CreateRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoom* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRoom* New() const final {
    return CreateMaybeMessage<CreateRoom>(nullptr);
  }

  CreateRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateRoom& from);
  void MergeFrom(const CreateRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.CreateRoom";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kGameModeFieldNumber = 1,
  };
  // optional string Password = 2;
  bool has_password() const;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // required int32 GameMode = 1;
  bool has_gamemode() const;
  void clear_gamemode();
  ::PROTOBUF_NAMESPACE_ID::int32 gamemode() const;
  void set_gamemode(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.CreateRoom)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::int32 gamemode_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class LeaveRoom :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.LeaveRoom) */ {
 public:
  LeaveRoom();
  virtual ~LeaveRoom();

  LeaveRoom(const LeaveRoom& from);
  LeaveRoom(LeaveRoom&& from) noexcept
    : LeaveRoom() {
    *this = ::std::move(from);
  }

  inline LeaveRoom& operator=(const LeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRoom& operator=(LeaveRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeaveRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaveRoom* internal_default_instance() {
    return reinterpret_cast<const LeaveRoom*>(
               &_LeaveRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LeaveRoom& a, LeaveRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRoom* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaveRoom* New() const final {
    return CreateMaybeMessage<LeaveRoom>(nullptr);
  }

  LeaveRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaveRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeaveRoom& from);
  void MergeFrom(const LeaveRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.LeaveRoom";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // optional int32 Reason = 1 [default = 0];
  bool has_reason() const;
  void clear_reason();
  ::PROTOBUF_NAMESPACE_ID::int32 reason() const;
  void set_reason(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.LeaveRoom)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 reason_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class RoomList_RoomInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.RoomList.RoomInfo) */ {
 public:
  RoomList_RoomInfo();
  virtual ~RoomList_RoomInfo();

  RoomList_RoomInfo(const RoomList_RoomInfo& from);
  RoomList_RoomInfo(RoomList_RoomInfo&& from) noexcept
    : RoomList_RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomList_RoomInfo& operator=(const RoomList_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomList_RoomInfo& operator=(RoomList_RoomInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomList_RoomInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomList_RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomList_RoomInfo*>(
               &_RoomList_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RoomList_RoomInfo& a, RoomList_RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomList_RoomInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomList_RoomInfo* New() const final {
    return CreateMaybeMessage<RoomList_RoomInfo>(nullptr);
  }

  RoomList_RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomList_RoomInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomList_RoomInfo& from);
  void MergeFrom(const RoomList_RoomInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomList_RoomInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.RoomList.RoomInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 2,
    kRoomChiefFieldNumber = 3,
    kRoomIndexFieldNumber = 1,
    kUserCountFieldNumber = 4,
    kMaxUserCountFieldNumber = 5,
    kNeedPasswordFieldNumber = 6,
    kGameModeFieldNumber = 7,
  };
  // required string RoomName = 2;
  bool has_roomname() const;
  void clear_roomname();
  const std::string& roomname() const;
  void set_roomname(const std::string& value);
  void set_roomname(std::string&& value);
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  std::string* mutable_roomname();
  std::string* release_roomname();
  void set_allocated_roomname(std::string* roomname);

  // required string RoomChief = 3;
  bool has_roomchief() const;
  void clear_roomchief();
  const std::string& roomchief() const;
  void set_roomchief(const std::string& value);
  void set_roomchief(std::string&& value);
  void set_roomchief(const char* value);
  void set_roomchief(const char* value, size_t size);
  std::string* mutable_roomchief();
  std::string* release_roomchief();
  void set_allocated_roomchief(std::string* roomchief);

  // required int32 RoomIndex = 1;
  bool has_roomindex() const;
  void clear_roomindex();
  ::PROTOBUF_NAMESPACE_ID::int32 roomindex() const;
  void set_roomindex(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required int32 UserCount = 4;
  bool has_usercount() const;
  void clear_usercount();
  ::PROTOBUF_NAMESPACE_ID::int32 usercount() const;
  void set_usercount(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required int32 MaxUserCount = 5;
  bool has_maxusercount() const;
  void clear_maxusercount();
  ::PROTOBUF_NAMESPACE_ID::int32 maxusercount() const;
  void set_maxusercount(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required int32 NeedPassword = 6;
  bool has_needpassword() const;
  void clear_needpassword();
  ::PROTOBUF_NAMESPACE_ID::int32 needpassword() const;
  void set_needpassword(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required int32 GameMode = 7;
  bool has_gamemode() const;
  void clear_gamemode();
  ::PROTOBUF_NAMESPACE_ID::int32 gamemode() const;
  void set_gamemode(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomList.RoomInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomchief_;
  ::PROTOBUF_NAMESPACE_ID::int32 roomindex_;
  ::PROTOBUF_NAMESPACE_ID::int32 usercount_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxusercount_;
  ::PROTOBUF_NAMESPACE_ID::int32 needpassword_;
  ::PROTOBUF_NAMESPACE_ID::int32 gamemode_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class RoomList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.RoomList) */ {
 public:
  RoomList();
  virtual ~RoomList();

  RoomList(const RoomList& from);
  RoomList(RoomList&& from) noexcept
    : RoomList() {
    *this = ::std::move(from);
  }

  inline RoomList& operator=(const RoomList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomList& operator=(RoomList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomList* internal_default_instance() {
    return reinterpret_cast<const RoomList*>(
               &_RoomList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RoomList& a, RoomList& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomList* New() const final {
    return CreateMaybeMessage<RoomList>(nullptr);
  }

  RoomList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomList& from);
  void MergeFrom(const RoomList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.RoomList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RoomList_RoomInfo RoomInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 10,
  };
  // repeated .SFPacketStore.RoomList.RoomInfo Info = 10;
  int info_size() const;
  void clear_info();
  ::SFPacketStore::RoomList_RoomInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >*
      mutable_info();
  const ::SFPacketStore::RoomList_RoomInfo& info(int index) const;
  ::SFPacketStore::RoomList_RoomInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >&
      info() const;

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo > info_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class RoomListRefresh :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.RoomListRefresh) */ {
 public:
  RoomListRefresh();
  virtual ~RoomListRefresh();

  RoomListRefresh(const RoomListRefresh& from);
  RoomListRefresh(RoomListRefresh&& from) noexcept
    : RoomListRefresh() {
    *this = ::std::move(from);
  }

  inline RoomListRefresh& operator=(const RoomListRefresh& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomListRefresh& operator=(RoomListRefresh&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomListRefresh& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomListRefresh* internal_default_instance() {
    return reinterpret_cast<const RoomListRefresh*>(
               &_RoomListRefresh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RoomListRefresh& a, RoomListRefresh& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomListRefresh* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomListRefresh* New() const final {
    return CreateMaybeMessage<RoomListRefresh>(nullptr);
  }

  RoomListRefresh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomListRefresh>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomListRefresh& from);
  void MergeFrom(const RoomListRefresh& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomListRefresh* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.RoomListRefresh";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomListRefresh)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class ChangeTeam :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.ChangeTeam) */ {
 public:
  ChangeTeam();
  virtual ~ChangeTeam();

  ChangeTeam(const ChangeTeam& from);
  ChangeTeam(ChangeTeam&& from) noexcept
    : ChangeTeam() {
    *this = ::std::move(from);
  }

  inline ChangeTeam& operator=(const ChangeTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeTeam& operator=(ChangeTeam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChangeTeam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeTeam* internal_default_instance() {
    return reinterpret_cast<const ChangeTeam*>(
               &_ChangeTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ChangeTeam& a, ChangeTeam& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeTeam* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeTeam* New() const final {
    return CreateMaybeMessage<ChangeTeam>(nullptr);
  }

  ChangeTeam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeTeam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChangeTeam& from);
  void MergeFrom(const ChangeTeam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeTeam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.ChangeTeam";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.ChangeTeam)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class LoadingStart :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.LoadingStart) */ {
 public:
  LoadingStart();
  virtual ~LoadingStart();

  LoadingStart(const LoadingStart& from);
  LoadingStart(LoadingStart&& from) noexcept
    : LoadingStart() {
    *this = ::std::move(from);
  }

  inline LoadingStart& operator=(const LoadingStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadingStart& operator=(LoadingStart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadingStart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadingStart* internal_default_instance() {
    return reinterpret_cast<const LoadingStart*>(
               &_LoadingStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(LoadingStart& a, LoadingStart& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadingStart* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadingStart* New() const final {
    return CreateMaybeMessage<LoadingStart>(nullptr);
  }

  LoadingStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadingStart>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadingStart& from);
  void MergeFrom(const LoadingStart& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadingStart* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.LoadingStart";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.LoadingStart)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class LoadingComplete :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.LoadingComplete) */ {
 public:
  LoadingComplete();
  virtual ~LoadingComplete();

  LoadingComplete(const LoadingComplete& from);
  LoadingComplete(LoadingComplete&& from) noexcept
    : LoadingComplete() {
    *this = ::std::move(from);
  }

  inline LoadingComplete& operator=(const LoadingComplete& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadingComplete& operator=(LoadingComplete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadingComplete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadingComplete* internal_default_instance() {
    return reinterpret_cast<const LoadingComplete*>(
               &_LoadingComplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(LoadingComplete& a, LoadingComplete& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadingComplete* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadingComplete* New() const final {
    return CreateMaybeMessage<LoadingComplete>(nullptr);
  }

  LoadingComplete* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadingComplete>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadingComplete& from);
  void MergeFrom(const LoadingComplete& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadingComplete* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.LoadingComplete";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.LoadingComplete)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class PlayStart :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.PlayStart) */ {
 public:
  PlayStart();
  virtual ~PlayStart();

  PlayStart(const PlayStart& from);
  PlayStart(PlayStart&& from) noexcept
    : PlayStart() {
    *this = ::std::move(from);
  }

  inline PlayStart& operator=(const PlayStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayStart& operator=(PlayStart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayStart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayStart* internal_default_instance() {
    return reinterpret_cast<const PlayStart*>(
               &_PlayStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PlayStart& a, PlayStart& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayStart* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayStart* New() const final {
    return CreateMaybeMessage<PlayStart>(nullptr);
  }

  PlayStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayStart>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayStart& from);
  void MergeFrom(const PlayStart& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayStart* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.PlayStart";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayStart)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class PlayMove :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.PlayMove) */ {
 public:
  PlayMove();
  virtual ~PlayMove();

  PlayMove(const PlayMove& from);
  PlayMove(PlayMove&& from) noexcept
    : PlayMove() {
    *this = ::std::move(from);
  }

  inline PlayMove& operator=(const PlayMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayMove& operator=(PlayMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayMove* internal_default_instance() {
    return reinterpret_cast<const PlayMove*>(
               &_PlayMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PlayMove& a, PlayMove& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayMove* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayMove* New() const final {
    return CreateMaybeMessage<PlayMove>(nullptr);
  }

  PlayMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayMove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayMove& from);
  void MergeFrom(const PlayMove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.PlayMove";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosXFieldNumber = 1,
    kPosYFieldNumber = 2,
    kPosZFieldNumber = 3,
  };
  // required float PosX = 1;
  bool has_posx() const;
  void clear_posx();
  float posx() const;
  void set_posx(float value);

  // required float PosY = 2;
  bool has_posy() const;
  void clear_posy();
  float posy() const;
  void set_posy(float value);

  // required float PosZ = 3;
  bool has_posz() const;
  void clear_posz();
  float posz() const;
  void set_posz(float value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayMove)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float posx_;
  float posy_;
  float posz_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class PlayEnd :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.PlayEnd) */ {
 public:
  PlayEnd();
  virtual ~PlayEnd();

  PlayEnd(const PlayEnd& from);
  PlayEnd(PlayEnd&& from) noexcept
    : PlayEnd() {
    *this = ::std::move(from);
  }

  inline PlayEnd& operator=(const PlayEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayEnd& operator=(PlayEnd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayEnd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayEnd* internal_default_instance() {
    return reinterpret_cast<const PlayEnd*>(
               &_PlayEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PlayEnd& a, PlayEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayEnd* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayEnd* New() const final {
    return CreateMaybeMessage<PlayEnd>(nullptr);
  }

  PlayEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayEnd>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayEnd& from);
  void MergeFrom(const PlayEnd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayEnd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.PlayEnd";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayEnd)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class PlayScoreInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.PlayScoreInfo) */ {
 public:
  PlayScoreInfo();
  virtual ~PlayScoreInfo();

  PlayScoreInfo(const PlayScoreInfo& from);
  PlayScoreInfo(PlayScoreInfo&& from) noexcept
    : PlayScoreInfo() {
    *this = ::std::move(from);
  }

  inline PlayScoreInfo& operator=(const PlayScoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayScoreInfo& operator=(PlayScoreInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayScoreInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayScoreInfo* internal_default_instance() {
    return reinterpret_cast<const PlayScoreInfo*>(
               &_PlayScoreInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(PlayScoreInfo& a, PlayScoreInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayScoreInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayScoreInfo* New() const final {
    return CreateMaybeMessage<PlayScoreInfo>(nullptr);
  }

  PlayScoreInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayScoreInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayScoreInfo& from);
  void MergeFrom(const PlayScoreInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayScoreInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.PlayScoreInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedKillCountFieldNumber = 1,
    kBlueKillCountFieldNumber = 2,
  };
  // required int32 RedKillCount = 1;
  bool has_redkillcount() const;
  void clear_redkillcount();
  ::PROTOBUF_NAMESPACE_ID::int32 redkillcount() const;
  void set_redkillcount(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required int32 BlueKillCount = 2;
  bool has_bluekillcount() const;
  void clear_bluekillcount();
  ::PROTOBUF_NAMESPACE_ID::int32 bluekillcount() const;
  void set_bluekillcount(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayScoreInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 redkillcount_;
  ::PROTOBUF_NAMESPACE_ID::int32 bluekillcount_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class PlayPlayerScore :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.PlayPlayerScore) */ {
 public:
  PlayPlayerScore();
  virtual ~PlayPlayerScore();

  PlayPlayerScore(const PlayPlayerScore& from);
  PlayPlayerScore(PlayPlayerScore&& from) noexcept
    : PlayPlayerScore() {
    *this = ::std::move(from);
  }

  inline PlayPlayerScore& operator=(const PlayPlayerScore& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayPlayerScore& operator=(PlayPlayerScore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayPlayerScore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayPlayerScore* internal_default_instance() {
    return reinterpret_cast<const PlayPlayerScore*>(
               &_PlayPlayerScore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PlayPlayerScore& a, PlayPlayerScore& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayPlayerScore* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayPlayerScore* New() const final {
    return CreateMaybeMessage<PlayPlayerScore>(nullptr);
  }

  PlayPlayerScore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayPlayerScore>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayPlayerScore& from);
  void MergeFrom(const PlayPlayerScore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayPlayerScore* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.PlayPlayerScore";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTeamtypeFieldNumber = 2,
    kKillFieldNumber = 3,
    kDeathFieldNumber = 4,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // required int32 teamtype = 2;
  bool has_teamtype() const;
  void clear_teamtype();
  ::PROTOBUF_NAMESPACE_ID::int32 teamtype() const;
  void set_teamtype(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required int32 kill = 3;
  bool has_kill() const;
  void clear_kill();
  ::PROTOBUF_NAMESPACE_ID::int32 kill() const;
  void set_kill(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required int32 death = 4;
  bool has_death() const;
  void clear_death();
  ::PROTOBUF_NAMESPACE_ID::int32 death() const;
  void set_death(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayPlayerScore)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 teamtype_;
  ::PROTOBUF_NAMESPACE_ID::int32 kill_;
  ::PROTOBUF_NAMESPACE_ID::int32 death_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class PeerList_PeerInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.PeerList.PeerInfo) */ {
 public:
  PeerList_PeerInfo();
  virtual ~PeerList_PeerInfo();

  PeerList_PeerInfo(const PeerList_PeerInfo& from);
  PeerList_PeerInfo(PeerList_PeerInfo&& from) noexcept
    : PeerList_PeerInfo() {
    *this = ::std::move(from);
  }

  inline PeerList_PeerInfo& operator=(const PeerList_PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerList_PeerInfo& operator=(PeerList_PeerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PeerList_PeerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerList_PeerInfo* internal_default_instance() {
    return reinterpret_cast<const PeerList_PeerInfo*>(
               &_PeerList_PeerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PeerList_PeerInfo& a, PeerList_PeerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerList_PeerInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeerList_PeerInfo* New() const final {
    return CreateMaybeMessage<PeerList_PeerInfo>(nullptr);
  }

  PeerList_PeerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeerList_PeerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PeerList_PeerInfo& from);
  void MergeFrom(const PeerList_PeerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerList_PeerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.PeerList.PeerInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kSerialFieldNumber = 1,
  };
  // required bytes Info = 2;
  bool has_info() const;
  void clear_info();
  const std::string& info() const;
  void set_info(const std::string& value);
  void set_info(std::string&& value);
  void set_info(const char* value);
  void set_info(const void* value, size_t size);
  std::string* mutable_info();
  std::string* release_info();
  void set_allocated_info(std::string* info);

  // required int32 serial = 1;
  bool has_serial() const;
  void clear_serial();
  ::PROTOBUF_NAMESPACE_ID::int32 serial() const;
  void set_serial(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PeerList.PeerInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::PROTOBUF_NAMESPACE_ID::int32 serial_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class PeerList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.PeerList) */ {
 public:
  PeerList();
  virtual ~PeerList();

  PeerList(const PeerList& from);
  PeerList(PeerList&& from) noexcept
    : PeerList() {
    *this = ::std::move(from);
  }

  inline PeerList& operator=(const PeerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerList& operator=(PeerList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PeerList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PeerList* internal_default_instance() {
    return reinterpret_cast<const PeerList*>(
               &_PeerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PeerList& a, PeerList& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeerList* New() const final {
    return CreateMaybeMessage<PeerList>(nullptr);
  }

  PeerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeerList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PeerList& from);
  void MergeFrom(const PeerList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.PeerList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PeerList_PeerInfo PeerInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 10,
  };
  // repeated .SFPacketStore.PeerList.PeerInfo Peer = 10;
  int peer_size() const;
  void clear_peer();
  ::SFPacketStore::PeerList_PeerInfo* mutable_peer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >*
      mutable_peer();
  const ::SFPacketStore::PeerList_PeerInfo& peer(int index) const;
  ::SFPacketStore::PeerList_PeerInfo* add_peer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >&
      peer() const;

  // @@protoc_insertion_point(class_scope:SFPacketStore.PeerList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo > peer_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class MSG_CREATE_PLAYER :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.MSG_CREATE_PLAYER) */ {
 public:
  MSG_CREATE_PLAYER();
  virtual ~MSG_CREATE_PLAYER();

  MSG_CREATE_PLAYER(const MSG_CREATE_PLAYER& from);
  MSG_CREATE_PLAYER(MSG_CREATE_PLAYER&& from) noexcept
    : MSG_CREATE_PLAYER() {
    *this = ::std::move(from);
  }

  inline MSG_CREATE_PLAYER& operator=(const MSG_CREATE_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline MSG_CREATE_PLAYER& operator=(MSG_CREATE_PLAYER&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MSG_CREATE_PLAYER& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MSG_CREATE_PLAYER* internal_default_instance() {
    return reinterpret_cast<const MSG_CREATE_PLAYER*>(
               &_MSG_CREATE_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(MSG_CREATE_PLAYER& a, MSG_CREATE_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(MSG_CREATE_PLAYER* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MSG_CREATE_PLAYER* New() const final {
    return CreateMaybeMessage<MSG_CREATE_PLAYER>(nullptr);
  }

  MSG_CREATE_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MSG_CREATE_PLAYER>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MSG_CREATE_PLAYER& from);
  void MergeFrom(const MSG_CREATE_PLAYER& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MSG_CREATE_PLAYER* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.MSG_CREATE_PLAYER";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialFieldNumber = 1,
    kSpawnindexFieldNumber = 2,
  };
  // required int32 Serial = 1;
  bool has_serial() const;
  void clear_serial();
  ::PROTOBUF_NAMESPACE_ID::int32 serial() const;
  void set_serial(::PROTOBUF_NAMESPACE_ID::int32 value);

  // required int32 spawnindex = 2;
  bool has_spawnindex() const;
  void clear_spawnindex();
  ::PROTOBUF_NAMESPACE_ID::int32 spawnindex() const;
  void set_spawnindex(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_CREATE_PLAYER)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 serial_;
  ::PROTOBUF_NAMESPACE_ID::int32 spawnindex_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class MSG_DESTROY_PLAYER :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.MSG_DESTROY_PLAYER) */ {
 public:
  MSG_DESTROY_PLAYER();
  virtual ~MSG_DESTROY_PLAYER();

  MSG_DESTROY_PLAYER(const MSG_DESTROY_PLAYER& from);
  MSG_DESTROY_PLAYER(MSG_DESTROY_PLAYER&& from) noexcept
    : MSG_DESTROY_PLAYER() {
    *this = ::std::move(from);
  }

  inline MSG_DESTROY_PLAYER& operator=(const MSG_DESTROY_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline MSG_DESTROY_PLAYER& operator=(MSG_DESTROY_PLAYER&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MSG_DESTROY_PLAYER& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MSG_DESTROY_PLAYER* internal_default_instance() {
    return reinterpret_cast<const MSG_DESTROY_PLAYER*>(
               &_MSG_DESTROY_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MSG_DESTROY_PLAYER& a, MSG_DESTROY_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(MSG_DESTROY_PLAYER* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MSG_DESTROY_PLAYER* New() const final {
    return CreateMaybeMessage<MSG_DESTROY_PLAYER>(nullptr);
  }

  MSG_DESTROY_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MSG_DESTROY_PLAYER>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MSG_DESTROY_PLAYER& from);
  void MergeFrom(const MSG_DESTROY_PLAYER& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MSG_DESTROY_PLAYER* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.MSG_DESTROY_PLAYER";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialFieldNumber = 1,
  };
  // required int32 Serial = 1;
  bool has_serial() const;
  void clear_serial();
  ::PROTOBUF_NAMESPACE_ID::int32 serial() const;
  void set_serial(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_DESTROY_PLAYER)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 serial_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class PLAYER_IP :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.PLAYER_IP) */ {
 public:
  PLAYER_IP();
  virtual ~PLAYER_IP();

  PLAYER_IP(const PLAYER_IP& from);
  PLAYER_IP(PLAYER_IP&& from) noexcept
    : PLAYER_IP() {
    *this = ::std::move(from);
  }

  inline PLAYER_IP& operator=(const PLAYER_IP& from) {
    CopyFrom(from);
    return *this;
  }
  inline PLAYER_IP& operator=(PLAYER_IP&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PLAYER_IP& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PLAYER_IP* internal_default_instance() {
    return reinterpret_cast<const PLAYER_IP*>(
               &_PLAYER_IP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(PLAYER_IP& a, PLAYER_IP& b) {
    a.Swap(&b);
  }
  inline void Swap(PLAYER_IP* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PLAYER_IP* New() const final {
    return CreateMaybeMessage<PLAYER_IP>(nullptr);
  }

  PLAYER_IP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PLAYER_IP>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PLAYER_IP& from);
  void MergeFrom(const PLAYER_IP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PLAYER_IP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.PLAYER_IP";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayeripFieldNumber = 1,
  };
  // required bytes playerip = 1;
  bool has_playerip() const;
  void clear_playerip();
  const std::string& playerip() const;
  void set_playerip(const std::string& value);
  void set_playerip(std::string&& value);
  void set_playerip(const char* value);
  void set_playerip(const void* value, size_t size);
  std::string* mutable_playerip();
  std::string* release_playerip();
  void set_allocated_playerip(std::string* playerip);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PLAYER_IP)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerip_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class ADD_PEER :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.ADD_PEER) */ {
 public:
  ADD_PEER();
  virtual ~ADD_PEER();

  ADD_PEER(const ADD_PEER& from);
  ADD_PEER(ADD_PEER&& from) noexcept
    : ADD_PEER() {
    *this = ::std::move(from);
  }

  inline ADD_PEER& operator=(const ADD_PEER& from) {
    CopyFrom(from);
    return *this;
  }
  inline ADD_PEER& operator=(ADD_PEER&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ADD_PEER& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ADD_PEER* internal_default_instance() {
    return reinterpret_cast<const ADD_PEER*>(
               &_ADD_PEER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ADD_PEER& a, ADD_PEER& b) {
    a.Swap(&b);
  }
  inline void Swap(ADD_PEER* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ADD_PEER* New() const final {
    return CreateMaybeMessage<ADD_PEER>(nullptr);
  }

  ADD_PEER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ADD_PEER>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ADD_PEER& from);
  void MergeFrom(const ADD_PEER& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ADD_PEER* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.ADD_PEER";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddpeerFieldNumber = 1,
  };
  // required bytes addpeer = 1;
  bool has_addpeer() const;
  void clear_addpeer();
  const std::string& addpeer() const;
  void set_addpeer(const std::string& value);
  void set_addpeer(std::string&& value);
  void set_addpeer(const char* value);
  void set_addpeer(const void* value, size_t size);
  std::string* mutable_addpeer();
  std::string* release_addpeer();
  void set_allocated_addpeer(std::string* addpeer);

  // @@protoc_insertion_point(class_scope:SFPacketStore.ADD_PEER)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addpeer_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// -------------------------------------------------------------------

class DELETE_PEER :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SFPacketStore.DELETE_PEER) */ {
 public:
  DELETE_PEER();
  virtual ~DELETE_PEER();

  DELETE_PEER(const DELETE_PEER& from);
  DELETE_PEER(DELETE_PEER&& from) noexcept
    : DELETE_PEER() {
    *this = ::std::move(from);
  }

  inline DELETE_PEER& operator=(const DELETE_PEER& from) {
    CopyFrom(from);
    return *this;
  }
  inline DELETE_PEER& operator=(DELETE_PEER&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DELETE_PEER& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DELETE_PEER* internal_default_instance() {
    return reinterpret_cast<const DELETE_PEER*>(
               &_DELETE_PEER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DELETE_PEER& a, DELETE_PEER& b) {
    a.Swap(&b);
  }
  inline void Swap(DELETE_PEER* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DELETE_PEER* New() const final {
    return CreateMaybeMessage<DELETE_PEER>(nullptr);
  }

  DELETE_PEER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DELETE_PEER>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DELETE_PEER& from);
  void MergeFrom(const DELETE_PEER& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DELETE_PEER* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SFPacketStore.DELETE_PEER";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SFPacketStore_2eproto);
    return ::descriptor_table_SFPacketStore_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialFieldNumber = 1,
  };
  // required int32 serial = 1;
  bool has_serial() const;
  void clear_serial();
  ::PROTOBUF_NAMESPACE_ID::int32 serial() const;
  void set_serial(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.DELETE_PEER)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 serial_;
  friend struct ::TableStruct_SFPacketStore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Login

// required string UserName = 1;
inline bool Login::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Login::username() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.Login.UserName)
  return username_.GetNoArena();
}
inline void Login::set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.Login.UserName)
}
inline void Login::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.Login.UserName)
}
inline void Login::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.Login.UserName)
}
inline void Login::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.Login.UserName)
}
inline std::string* Login::mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.Login.UserName)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Login::release_username() {
  // @@protoc_insertion_point(field_release:SFPacketStore.Login.UserName)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.Login.UserName)
}

// required string Password = 2;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Login::password() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.Login.Password)
  return password_.GetNoArena();
}
inline void Login::set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.Login.Password)
}
inline void Login::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.Login.Password)
}
inline void Login::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.Login.Password)
}
inline void Login::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.Login.Password)
}
inline std::string* Login::mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.Login.Password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Login::release_password() {
  // @@protoc_insertion_point(field_release:SFPacketStore.Login.Password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.Login.Password)
}

// -------------------------------------------------------------------

// LoginSuccess

// required int32 Result = 1;
inline bool LoginSuccess::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginSuccess::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginSuccess::result() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.LoginSuccess.Result)
  return result_;
}
inline void LoginSuccess::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  result_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.LoginSuccess.Result)
}

// required bytes UserInfo = 2;
inline bool LoginSuccess::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginSuccess::clear_userinfo() {
  userinfo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginSuccess::userinfo() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.LoginSuccess.UserInfo)
  return userinfo_.GetNoArena();
}
inline void LoginSuccess::set_userinfo(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  userinfo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.LoginSuccess.UserInfo)
}
inline void LoginSuccess::set_userinfo(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  userinfo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.LoginSuccess.UserInfo)
}
inline void LoginSuccess::set_userinfo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  userinfo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.LoginSuccess.UserInfo)
}
inline void LoginSuccess::set_userinfo(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  userinfo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.LoginSuccess.UserInfo)
}
inline std::string* LoginSuccess::mutable_userinfo() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.LoginSuccess.UserInfo)
  return userinfo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginSuccess::release_userinfo() {
  // @@protoc_insertion_point(field_release:SFPacketStore.LoginSuccess.UserInfo)
  if (!has_userinfo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return userinfo_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginSuccess::set_allocated_userinfo(std::string* userinfo) {
  if (userinfo != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  userinfo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userinfo);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.LoginSuccess.UserInfo)
}

// -------------------------------------------------------------------

// LoginFail

// required int32 Result = 1;
inline bool LoginFail::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginFail::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginFail::result() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.LoginFail.Result)
  return result_;
}
inline void LoginFail::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.LoginFail.Result)
}

// -------------------------------------------------------------------

// TeamInfo_TeamMember

// required string Member = 1;
inline bool TeamInfo_TeamMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamInfo_TeamMember::clear_member() {
  member_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TeamInfo_TeamMember::member() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.TeamInfo.TeamMember.Member)
  return member_.GetNoArena();
}
inline void TeamInfo_TeamMember::set_member(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.TeamInfo.TeamMember.Member)
}
inline void TeamInfo_TeamMember::set_member(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.TeamInfo.TeamMember.Member)
}
inline void TeamInfo_TeamMember::set_member(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.TeamInfo.TeamMember.Member)
}
inline void TeamInfo_TeamMember::set_member(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.TeamInfo.TeamMember.Member)
}
inline std::string* TeamInfo_TeamMember::mutable_member() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.TeamInfo.TeamMember.Member)
  return member_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TeamInfo_TeamMember::release_member() {
  // @@protoc_insertion_point(field_release:SFPacketStore.TeamInfo.TeamMember.Member)
  if (!has_member()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return member_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TeamInfo_TeamMember::set_allocated_member(std::string* member) {
  if (member != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  member_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), member);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.TeamInfo.TeamMember.Member)
}

// -------------------------------------------------------------------

// TeamInfo

// required .SFPacketStore.TeamType Type = 1 [default = RED];
inline bool TeamInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamInfo::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::SFPacketStore::TeamType TeamInfo::type() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.TeamInfo.Type)
  return static_cast< ::SFPacketStore::TeamType >(type_);
}
inline void TeamInfo::set_type(::SFPacketStore::TeamType value) {
  assert(::SFPacketStore::TeamType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.TeamInfo.Type)
}

// repeated .SFPacketStore.TeamInfo.TeamMember Member = 6;
inline int TeamInfo::member_size() const {
  return member_.size();
}
inline void TeamInfo::clear_member() {
  member_.Clear();
}
inline ::SFPacketStore::TeamInfo_TeamMember* TeamInfo::mutable_member(int index) {
  // @@protoc_insertion_point(field_mutable:SFPacketStore.TeamInfo.Member)
  return member_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >*
TeamInfo::mutable_member() {
  // @@protoc_insertion_point(field_mutable_list:SFPacketStore.TeamInfo.Member)
  return &member_;
}
inline const ::SFPacketStore::TeamInfo_TeamMember& TeamInfo::member(int index) const {
  // @@protoc_insertion_point(field_get:SFPacketStore.TeamInfo.Member)
  return member_.Get(index);
}
inline ::SFPacketStore::TeamInfo_TeamMember* TeamInfo::add_member() {
  // @@protoc_insertion_point(field_add:SFPacketStore.TeamInfo.Member)
  return member_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >&
TeamInfo::member() const {
  // @@protoc_insertion_point(field_list:SFPacketStore.TeamInfo.Member)
  return member_;
}

// -------------------------------------------------------------------

// RoomMember_Member

// required string Member = 1;
inline bool RoomMember_Member::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomMember_Member::clear_member() {
  member_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoomMember_Member::member() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomMember.Member.Member)
  return member_.GetNoArena();
}
inline void RoomMember_Member::set_member(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomMember.Member.Member)
}
inline void RoomMember_Member::set_member(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.RoomMember.Member.Member)
}
inline void RoomMember_Member::set_member(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.RoomMember.Member.Member)
}
inline void RoomMember_Member::set_member(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.RoomMember.Member.Member)
}
inline std::string* RoomMember_Member::mutable_member() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.RoomMember.Member.Member)
  return member_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoomMember_Member::release_member() {
  // @@protoc_insertion_point(field_release:SFPacketStore.RoomMember.Member.Member)
  if (!has_member()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return member_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoomMember_Member::set_allocated_member(std::string* member) {
  if (member != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  member_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), member);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.RoomMember.Member.Member)
}

// required int32 PlayerIndex = 2;
inline bool RoomMember_Member::has_playerindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomMember_Member::clear_playerindex() {
  playerindex_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomMember_Member::playerindex() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomMember.Member.PlayerIndex)
  return playerindex_;
}
inline void RoomMember_Member::set_playerindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerindex_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomMember.Member.PlayerIndex)
}

// required .SFPacketStore.TeamType Type = 3;
inline bool RoomMember_Member::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomMember_Member::clear_type() {
  type_ = -1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::SFPacketStore::TeamType RoomMember_Member::type() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomMember.Member.Type)
  return static_cast< ::SFPacketStore::TeamType >(type_);
}
inline void RoomMember_Member::set_type(::SFPacketStore::TeamType value) {
  assert(::SFPacketStore::TeamType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomMember.Member.Type)
}

// -------------------------------------------------------------------

// RoomMember

// repeated .SFPacketStore.RoomMember.Member Info = 12;
inline int RoomMember::info_size() const {
  return info_.size();
}
inline void RoomMember::clear_info() {
  info_.Clear();
}
inline ::SFPacketStore::RoomMember_Member* RoomMember::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:SFPacketStore.RoomMember.Info)
  return info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomMember_Member >*
RoomMember::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:SFPacketStore.RoomMember.Info)
  return &info_;
}
inline const ::SFPacketStore::RoomMember_Member& RoomMember::info(int index) const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomMember.Info)
  return info_.Get(index);
}
inline ::SFPacketStore::RoomMember_Member* RoomMember::add_info() {
  // @@protoc_insertion_point(field_add:SFPacketStore.RoomMember.Info)
  return info_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomMember_Member >&
RoomMember::info() const {
  // @@protoc_insertion_point(field_list:SFPacketStore.RoomMember.Info)
  return info_;
}

// -------------------------------------------------------------------

// EnterTeamMember

// required string Member = 1;
inline bool EnterTeamMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterTeamMember::clear_member() {
  member_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EnterTeamMember::member() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.EnterTeamMember.Member)
  return member_.GetNoArena();
}
inline void EnterTeamMember::set_member(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.EnterTeamMember.Member)
}
inline void EnterTeamMember::set_member(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.EnterTeamMember.Member)
}
inline void EnterTeamMember::set_member(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.EnterTeamMember.Member)
}
inline void EnterTeamMember::set_member(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.EnterTeamMember.Member)
}
inline std::string* EnterTeamMember::mutable_member() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.EnterTeamMember.Member)
  return member_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EnterTeamMember::release_member() {
  // @@protoc_insertion_point(field_release:SFPacketStore.EnterTeamMember.Member)
  if (!has_member()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return member_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EnterTeamMember::set_allocated_member(std::string* member) {
  if (member != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  member_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), member);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.EnterTeamMember.Member)
}

// required int32 PlayerIndex = 2;
inline bool EnterTeamMember::has_playerindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterTeamMember::clear_playerindex() {
  playerindex_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EnterTeamMember::playerindex() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.EnterTeamMember.PlayerIndex)
  return playerindex_;
}
inline void EnterTeamMember::set_playerindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerindex_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.EnterTeamMember.PlayerIndex)
}

// required .SFPacketStore.TeamType Type = 3;
inline bool EnterTeamMember::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterTeamMember::clear_type() {
  type_ = -1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::SFPacketStore::TeamType EnterTeamMember::type() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.EnterTeamMember.Type)
  return static_cast< ::SFPacketStore::TeamType >(type_);
}
inline void EnterTeamMember::set_type(::SFPacketStore::TeamType value) {
  assert(::SFPacketStore::TeamType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.EnterTeamMember.Type)
}

// -------------------------------------------------------------------

// LeaveTeamMember

// required string Member = 1;
inline bool LeaveTeamMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveTeamMember::clear_member() {
  member_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LeaveTeamMember::member() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.LeaveTeamMember.Member)
  return member_.GetNoArena();
}
inline void LeaveTeamMember::set_member(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.LeaveTeamMember.Member)
}
inline void LeaveTeamMember::set_member(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.LeaveTeamMember.Member)
}
inline void LeaveTeamMember::set_member(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.LeaveTeamMember.Member)
}
inline void LeaveTeamMember::set_member(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  member_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.LeaveTeamMember.Member)
}
inline std::string* LeaveTeamMember::mutable_member() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.LeaveTeamMember.Member)
  return member_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LeaveTeamMember::release_member() {
  // @@protoc_insertion_point(field_release:SFPacketStore.LeaveTeamMember.Member)
  if (!has_member()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return member_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LeaveTeamMember::set_allocated_member(std::string* member) {
  if (member != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  member_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), member);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.LeaveTeamMember.Member)
}

// required int32 PlayerIndex = 2;
inline bool LeaveTeamMember::has_playerindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveTeamMember::clear_playerindex() {
  playerindex_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LeaveTeamMember::playerindex() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.LeaveTeamMember.PlayerIndex)
  return playerindex_;
}
inline void LeaveTeamMember::set_playerindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerindex_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.LeaveTeamMember.PlayerIndex)
}

// required .SFPacketStore.TeamType Type = 3;
inline bool LeaveTeamMember::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaveTeamMember::clear_type() {
  type_ = -1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::SFPacketStore::TeamType LeaveTeamMember::type() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.LeaveTeamMember.Type)
  return static_cast< ::SFPacketStore::TeamType >(type_);
}
inline void LeaveTeamMember::set_type(::SFPacketStore::TeamType value) {
  assert(::SFPacketStore::TeamType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.LeaveTeamMember.Type)
}

// -------------------------------------------------------------------

// InvalidPacket

// required string Arg = 1;
inline bool InvalidPacket::has_arg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvalidPacket::clear_arg() {
  arg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InvalidPacket::arg() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.InvalidPacket.Arg)
  return arg_.GetNoArena();
}
inline void InvalidPacket::set_arg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  arg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.InvalidPacket.Arg)
}
inline void InvalidPacket::set_arg(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  arg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.InvalidPacket.Arg)
}
inline void InvalidPacket::set_arg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  arg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.InvalidPacket.Arg)
}
inline void InvalidPacket::set_arg(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  arg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.InvalidPacket.Arg)
}
inline std::string* InvalidPacket::mutable_arg() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.InvalidPacket.Arg)
  return arg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InvalidPacket::release_arg() {
  // @@protoc_insertion_point(field_release:SFPacketStore.InvalidPacket.Arg)
  if (!has_arg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return arg_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InvalidPacket::set_allocated_arg(std::string* arg) {
  if (arg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  arg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arg);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.InvalidPacket.Arg)
}

// -------------------------------------------------------------------

// EnterLobby

// optional int32 LobbyIndex = 1 [default = 0];
inline bool EnterLobby::has_lobbyindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterLobby::clear_lobbyindex() {
  lobbyindex_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EnterLobby::lobbyindex() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.EnterLobby.LobbyIndex)
  return lobbyindex_;
}
inline void EnterLobby::set_lobbyindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  lobbyindex_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.EnterLobby.LobbyIndex)
}

// -------------------------------------------------------------------

// ChatReq

// required string Message = 1;
inline bool ChatReq::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReq::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatReq::message() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.ChatReq.Message)
  return message_.GetNoArena();
}
inline void ChatReq::set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.ChatReq.Message)
}
inline void ChatReq::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.ChatReq.Message)
}
inline void ChatReq::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.ChatReq.Message)
}
inline void ChatReq::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.ChatReq.Message)
}
inline std::string* ChatReq::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.ChatReq.Message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChatReq::release_message() {
  // @@protoc_insertion_point(field_release:SFPacketStore.ChatReq.Message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChatReq::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.ChatReq.Message)
}

// -------------------------------------------------------------------

// ChatRes

// required string Sender = 1;
inline bool ChatRes::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRes::clear_sender() {
  sender_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatRes::sender() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.ChatRes.Sender)
  return sender_.GetNoArena();
}
inline void ChatRes::set_sender(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sender_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.ChatRes.Sender)
}
inline void ChatRes::set_sender(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  sender_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.ChatRes.Sender)
}
inline void ChatRes::set_sender(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  sender_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.ChatRes.Sender)
}
inline void ChatRes::set_sender(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  sender_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.ChatRes.Sender)
}
inline std::string* ChatRes::mutable_sender() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.ChatRes.Sender)
  return sender_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChatRes::release_sender() {
  // @@protoc_insertion_point(field_release:SFPacketStore.ChatRes.Sender)
  if (!has_sender()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sender_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChatRes::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sender_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.ChatRes.Sender)
}

// required string Message = 2;
inline bool ChatRes::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRes::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChatRes::message() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.ChatRes.Message)
  return message_.GetNoArena();
}
inline void ChatRes::set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.ChatRes.Message)
}
inline void ChatRes::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.ChatRes.Message)
}
inline void ChatRes::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.ChatRes.Message)
}
inline void ChatRes::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.ChatRes.Message)
}
inline std::string* ChatRes::mutable_message() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.ChatRes.Message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChatRes::release_message() {
  // @@protoc_insertion_point(field_release:SFPacketStore.ChatRes.Message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChatRes::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.ChatRes.Message)
}

// -------------------------------------------------------------------

// EnterRoom

// required int32 RoomIndex = 1;
inline bool EnterRoom::has_roomindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoom::clear_roomindex() {
  roomindex_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EnterRoom::roomindex() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.EnterRoom.RoomIndex)
  return roomindex_;
}
inline void EnterRoom::set_roomindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  roomindex_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.EnterRoom.RoomIndex)
}

// required int32 GameMode = 2;
inline bool EnterRoom::has_gamemode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoom::clear_gamemode() {
  gamemode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EnterRoom::gamemode() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.EnterRoom.GameMode)
  return gamemode_;
}
inline void EnterRoom::set_gamemode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  gamemode_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.EnterRoom.GameMode)
}

// optional string Password = 3;
inline bool EnterRoom::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoom::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EnterRoom::password() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.EnterRoom.Password)
  return password_.GetNoArena();
}
inline void EnterRoom::set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.EnterRoom.Password)
}
inline void EnterRoom::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.EnterRoom.Password)
}
inline void EnterRoom::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.EnterRoom.Password)
}
inline void EnterRoom::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.EnterRoom.Password)
}
inline std::string* EnterRoom::mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.EnterRoom.Password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EnterRoom::release_password() {
  // @@protoc_insertion_point(field_release:SFPacketStore.EnterRoom.Password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EnterRoom::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.EnterRoom.Password)
}

// -------------------------------------------------------------------

// CreateRoom

// required int32 GameMode = 1;
inline bool CreateRoom::has_gamemode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoom::clear_gamemode() {
  gamemode_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateRoom::gamemode() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.CreateRoom.GameMode)
  return gamemode_;
}
inline void CreateRoom::set_gamemode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  gamemode_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.CreateRoom.GameMode)
}

// optional string Password = 2;
inline bool CreateRoom::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoom::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateRoom::password() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.CreateRoom.Password)
  return password_.GetNoArena();
}
inline void CreateRoom::set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.CreateRoom.Password)
}
inline void CreateRoom::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.CreateRoom.Password)
}
inline void CreateRoom::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.CreateRoom.Password)
}
inline void CreateRoom::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.CreateRoom.Password)
}
inline std::string* CreateRoom::mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.CreateRoom.Password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CreateRoom::release_password() {
  // @@protoc_insertion_point(field_release:SFPacketStore.CreateRoom.Password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoom::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.CreateRoom.Password)
}

// -------------------------------------------------------------------

// LeaveRoom

// optional int32 Reason = 1 [default = 0];
inline bool LeaveRoom::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveRoom::clear_reason() {
  reason_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LeaveRoom::reason() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.LeaveRoom.Reason)
  return reason_;
}
inline void LeaveRoom::set_reason(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  reason_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.LeaveRoom.Reason)
}

// -------------------------------------------------------------------

// RoomList_RoomInfo

// required int32 RoomIndex = 1;
inline bool RoomList_RoomInfo::has_roomindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomList_RoomInfo::clear_roomindex() {
  roomindex_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomList_RoomInfo::roomindex() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomList.RoomInfo.RoomIndex)
  return roomindex_;
}
inline void RoomList_RoomInfo::set_roomindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  roomindex_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomList.RoomInfo.RoomIndex)
}

// required string RoomName = 2;
inline bool RoomList_RoomInfo::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomList_RoomInfo::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoomList_RoomInfo::roomname() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomList.RoomInfo.RoomName)
  return roomname_.GetNoArena();
}
inline void RoomList_RoomInfo::set_roomname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  roomname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomList.RoomInfo.RoomName)
}
inline void RoomList_RoomInfo::set_roomname(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  roomname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.RoomList.RoomInfo.RoomName)
}
inline void RoomList_RoomInfo::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  roomname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.RoomList.RoomInfo.RoomName)
}
inline void RoomList_RoomInfo::set_roomname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  roomname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.RoomList.RoomInfo.RoomName)
}
inline std::string* RoomList_RoomInfo::mutable_roomname() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.RoomList.RoomInfo.RoomName)
  return roomname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoomList_RoomInfo::release_roomname() {
  // @@protoc_insertion_point(field_release:SFPacketStore.RoomList.RoomInfo.RoomName)
  if (!has_roomname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return roomname_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoomList_RoomInfo::set_allocated_roomname(std::string* roomname) {
  if (roomname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  roomname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.RoomList.RoomInfo.RoomName)
}

// required string RoomChief = 3;
inline bool RoomList_RoomInfo::has_roomchief() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomList_RoomInfo::clear_roomchief() {
  roomchief_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RoomList_RoomInfo::roomchief() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomList.RoomInfo.RoomChief)
  return roomchief_.GetNoArena();
}
inline void RoomList_RoomInfo::set_roomchief(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  roomchief_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomList.RoomInfo.RoomChief)
}
inline void RoomList_RoomInfo::set_roomchief(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  roomchief_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.RoomList.RoomInfo.RoomChief)
}
inline void RoomList_RoomInfo::set_roomchief(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  roomchief_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.RoomList.RoomInfo.RoomChief)
}
inline void RoomList_RoomInfo::set_roomchief(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  roomchief_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.RoomList.RoomInfo.RoomChief)
}
inline std::string* RoomList_RoomInfo::mutable_roomchief() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.RoomList.RoomInfo.RoomChief)
  return roomchief_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoomList_RoomInfo::release_roomchief() {
  // @@protoc_insertion_point(field_release:SFPacketStore.RoomList.RoomInfo.RoomChief)
  if (!has_roomchief()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return roomchief_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoomList_RoomInfo::set_allocated_roomchief(std::string* roomchief) {
  if (roomchief != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  roomchief_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roomchief);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.RoomList.RoomInfo.RoomChief)
}

// required int32 UserCount = 4;
inline bool RoomList_RoomInfo::has_usercount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomList_RoomInfo::clear_usercount() {
  usercount_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomList_RoomInfo::usercount() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomList.RoomInfo.UserCount)
  return usercount_;
}
inline void RoomList_RoomInfo::set_usercount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  usercount_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomList.RoomInfo.UserCount)
}

// required int32 MaxUserCount = 5;
inline bool RoomList_RoomInfo::has_maxusercount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomList_RoomInfo::clear_maxusercount() {
  maxusercount_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomList_RoomInfo::maxusercount() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomList.RoomInfo.MaxUserCount)
  return maxusercount_;
}
inline void RoomList_RoomInfo::set_maxusercount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  maxusercount_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomList.RoomInfo.MaxUserCount)
}

// required int32 NeedPassword = 6;
inline bool RoomList_RoomInfo::has_needpassword() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomList_RoomInfo::clear_needpassword() {
  needpassword_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomList_RoomInfo::needpassword() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomList.RoomInfo.NeedPassword)
  return needpassword_;
}
inline void RoomList_RoomInfo::set_needpassword(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  needpassword_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomList.RoomInfo.NeedPassword)
}

// required int32 GameMode = 7;
inline bool RoomList_RoomInfo::has_gamemode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomList_RoomInfo::clear_gamemode() {
  gamemode_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomList_RoomInfo::gamemode() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomList.RoomInfo.GameMode)
  return gamemode_;
}
inline void RoomList_RoomInfo::set_gamemode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  gamemode_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.RoomList.RoomInfo.GameMode)
}

// -------------------------------------------------------------------

// RoomList

// repeated .SFPacketStore.RoomList.RoomInfo Info = 10;
inline int RoomList::info_size() const {
  return info_.size();
}
inline void RoomList::clear_info() {
  info_.Clear();
}
inline ::SFPacketStore::RoomList_RoomInfo* RoomList::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:SFPacketStore.RoomList.Info)
  return info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >*
RoomList::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:SFPacketStore.RoomList.Info)
  return &info_;
}
inline const ::SFPacketStore::RoomList_RoomInfo& RoomList::info(int index) const {
  // @@protoc_insertion_point(field_get:SFPacketStore.RoomList.Info)
  return info_.Get(index);
}
inline ::SFPacketStore::RoomList_RoomInfo* RoomList::add_info() {
  // @@protoc_insertion_point(field_add:SFPacketStore.RoomList.Info)
  return info_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >&
RoomList::info() const {
  // @@protoc_insertion_point(field_list:SFPacketStore.RoomList.Info)
  return info_;
}

// -------------------------------------------------------------------

// RoomListRefresh

// -------------------------------------------------------------------

// ChangeTeam

// -------------------------------------------------------------------

// LoadingStart

// -------------------------------------------------------------------

// LoadingComplete

// -------------------------------------------------------------------

// PlayStart

// -------------------------------------------------------------------

// PlayMove

// required float PosX = 1;
inline bool PlayMove::has_posx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayMove::clear_posx() {
  posx_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float PlayMove::posx() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PlayMove.PosX)
  return posx_;
}
inline void PlayMove::set_posx(float value) {
  _has_bits_[0] |= 0x00000001u;
  posx_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.PlayMove.PosX)
}

// required float PosY = 2;
inline bool PlayMove::has_posy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayMove::clear_posy() {
  posy_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float PlayMove::posy() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PlayMove.PosY)
  return posy_;
}
inline void PlayMove::set_posy(float value) {
  _has_bits_[0] |= 0x00000002u;
  posy_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.PlayMove.PosY)
}

// required float PosZ = 3;
inline bool PlayMove::has_posz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayMove::clear_posz() {
  posz_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float PlayMove::posz() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PlayMove.PosZ)
  return posz_;
}
inline void PlayMove::set_posz(float value) {
  _has_bits_[0] |= 0x00000004u;
  posz_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.PlayMove.PosZ)
}

// -------------------------------------------------------------------

// PlayEnd

// -------------------------------------------------------------------

// PlayScoreInfo

// required int32 RedKillCount = 1;
inline bool PlayScoreInfo::has_redkillcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayScoreInfo::clear_redkillcount() {
  redkillcount_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayScoreInfo::redkillcount() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PlayScoreInfo.RedKillCount)
  return redkillcount_;
}
inline void PlayScoreInfo::set_redkillcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  redkillcount_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.PlayScoreInfo.RedKillCount)
}

// required int32 BlueKillCount = 2;
inline bool PlayScoreInfo::has_bluekillcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayScoreInfo::clear_bluekillcount() {
  bluekillcount_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayScoreInfo::bluekillcount() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PlayScoreInfo.BlueKillCount)
  return bluekillcount_;
}
inline void PlayScoreInfo::set_bluekillcount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  bluekillcount_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.PlayScoreInfo.BlueKillCount)
}

// -------------------------------------------------------------------

// PlayPlayerScore

// required string name = 1;
inline bool PlayPlayerScore::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayPlayerScore::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayPlayerScore::name() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PlayPlayerScore.name)
  return name_.GetNoArena();
}
inline void PlayPlayerScore::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.PlayPlayerScore.name)
}
inline void PlayPlayerScore::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.PlayPlayerScore.name)
}
inline void PlayPlayerScore::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.PlayPlayerScore.name)
}
inline void PlayPlayerScore::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.PlayPlayerScore.name)
}
inline std::string* PlayPlayerScore::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.PlayPlayerScore.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PlayPlayerScore::release_name() {
  // @@protoc_insertion_point(field_release:SFPacketStore.PlayPlayerScore.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PlayPlayerScore::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.PlayPlayerScore.name)
}

// required int32 teamtype = 2;
inline bool PlayPlayerScore::has_teamtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayPlayerScore::clear_teamtype() {
  teamtype_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayPlayerScore::teamtype() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PlayPlayerScore.teamtype)
  return teamtype_;
}
inline void PlayPlayerScore::set_teamtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  teamtype_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.PlayPlayerScore.teamtype)
}

// required int32 kill = 3;
inline bool PlayPlayerScore::has_kill() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayPlayerScore::clear_kill() {
  kill_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayPlayerScore::kill() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PlayPlayerScore.kill)
  return kill_;
}
inline void PlayPlayerScore::set_kill(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  kill_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.PlayPlayerScore.kill)
}

// required int32 death = 4;
inline bool PlayPlayerScore::has_death() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayPlayerScore::clear_death() {
  death_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayPlayerScore::death() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PlayPlayerScore.death)
  return death_;
}
inline void PlayPlayerScore::set_death(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  death_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.PlayPlayerScore.death)
}

// -------------------------------------------------------------------

// PeerList_PeerInfo

// required int32 serial = 1;
inline bool PeerList_PeerInfo::has_serial() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerList_PeerInfo::clear_serial() {
  serial_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PeerList_PeerInfo::serial() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PeerList.PeerInfo.serial)
  return serial_;
}
inline void PeerList_PeerInfo::set_serial(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  serial_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.PeerList.PeerInfo.serial)
}

// required bytes Info = 2;
inline bool PeerList_PeerInfo::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeerList_PeerInfo::clear_info() {
  info_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PeerList_PeerInfo::info() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PeerList.PeerInfo.Info)
  return info_.GetNoArena();
}
inline void PeerList_PeerInfo::set_info(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.PeerList.PeerInfo.Info)
}
inline void PeerList_PeerInfo::set_info(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  info_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.PeerList.PeerInfo.Info)
}
inline void PeerList_PeerInfo::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.PeerList.PeerInfo.Info)
}
inline void PeerList_PeerInfo::set_info(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.PeerList.PeerInfo.Info)
}
inline std::string* PeerList_PeerInfo::mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.PeerList.PeerInfo.Info)
  return info_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PeerList_PeerInfo::release_info() {
  // @@protoc_insertion_point(field_release:SFPacketStore.PeerList.PeerInfo.Info)
  if (!has_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return info_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PeerList_PeerInfo::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.PeerList.PeerInfo.Info)
}

// -------------------------------------------------------------------

// PeerList

// repeated .SFPacketStore.PeerList.PeerInfo Peer = 10;
inline int PeerList::peer_size() const {
  return peer_.size();
}
inline void PeerList::clear_peer() {
  peer_.Clear();
}
inline ::SFPacketStore::PeerList_PeerInfo* PeerList::mutable_peer(int index) {
  // @@protoc_insertion_point(field_mutable:SFPacketStore.PeerList.Peer)
  return peer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >*
PeerList::mutable_peer() {
  // @@protoc_insertion_point(field_mutable_list:SFPacketStore.PeerList.Peer)
  return &peer_;
}
inline const ::SFPacketStore::PeerList_PeerInfo& PeerList::peer(int index) const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PeerList.Peer)
  return peer_.Get(index);
}
inline ::SFPacketStore::PeerList_PeerInfo* PeerList::add_peer() {
  // @@protoc_insertion_point(field_add:SFPacketStore.PeerList.Peer)
  return peer_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >&
PeerList::peer() const {
  // @@protoc_insertion_point(field_list:SFPacketStore.PeerList.Peer)
  return peer_;
}

// -------------------------------------------------------------------

// MSG_CREATE_PLAYER

// required int32 Serial = 1;
inline bool MSG_CREATE_PLAYER::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_CREATE_PLAYER::clear_serial() {
  serial_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MSG_CREATE_PLAYER::serial() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.MSG_CREATE_PLAYER.Serial)
  return serial_;
}
inline void MSG_CREATE_PLAYER::set_serial(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  serial_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.MSG_CREATE_PLAYER.Serial)
}

// required int32 spawnindex = 2;
inline bool MSG_CREATE_PLAYER::has_spawnindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MSG_CREATE_PLAYER::clear_spawnindex() {
  spawnindex_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MSG_CREATE_PLAYER::spawnindex() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.MSG_CREATE_PLAYER.spawnindex)
  return spawnindex_;
}
inline void MSG_CREATE_PLAYER::set_spawnindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  spawnindex_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.MSG_CREATE_PLAYER.spawnindex)
}

// -------------------------------------------------------------------

// MSG_DESTROY_PLAYER

// required int32 Serial = 1;
inline bool MSG_DESTROY_PLAYER::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_DESTROY_PLAYER::clear_serial() {
  serial_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MSG_DESTROY_PLAYER::serial() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.MSG_DESTROY_PLAYER.Serial)
  return serial_;
}
inline void MSG_DESTROY_PLAYER::set_serial(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  serial_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.MSG_DESTROY_PLAYER.Serial)
}

// -------------------------------------------------------------------

// PLAYER_IP

// required bytes playerip = 1;
inline bool PLAYER_IP::has_playerip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PLAYER_IP::clear_playerip() {
  playerip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PLAYER_IP::playerip() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.PLAYER_IP.playerip)
  return playerip_.GetNoArena();
}
inline void PLAYER_IP::set_playerip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playerip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.PLAYER_IP.playerip)
}
inline void PLAYER_IP::set_playerip(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  playerip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.PLAYER_IP.playerip)
}
inline void PLAYER_IP::set_playerip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  playerip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.PLAYER_IP.playerip)
}
inline void PLAYER_IP::set_playerip(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  playerip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.PLAYER_IP.playerip)
}
inline std::string* PLAYER_IP::mutable_playerip() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.PLAYER_IP.playerip)
  return playerip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PLAYER_IP::release_playerip() {
  // @@protoc_insertion_point(field_release:SFPacketStore.PLAYER_IP.playerip)
  if (!has_playerip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return playerip_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PLAYER_IP::set_allocated_playerip(std::string* playerip) {
  if (playerip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerip);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.PLAYER_IP.playerip)
}

// -------------------------------------------------------------------

// ADD_PEER

// required bytes addpeer = 1;
inline bool ADD_PEER::has_addpeer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ADD_PEER::clear_addpeer() {
  addpeer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ADD_PEER::addpeer() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.ADD_PEER.addpeer)
  return addpeer_.GetNoArena();
}
inline void ADD_PEER::set_addpeer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  addpeer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SFPacketStore.ADD_PEER.addpeer)
}
inline void ADD_PEER::set_addpeer(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  addpeer_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SFPacketStore.ADD_PEER.addpeer)
}
inline void ADD_PEER::set_addpeer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  addpeer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SFPacketStore.ADD_PEER.addpeer)
}
inline void ADD_PEER::set_addpeer(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  addpeer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SFPacketStore.ADD_PEER.addpeer)
}
inline std::string* ADD_PEER::mutable_addpeer() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:SFPacketStore.ADD_PEER.addpeer)
  return addpeer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ADD_PEER::release_addpeer() {
  // @@protoc_insertion_point(field_release:SFPacketStore.ADD_PEER.addpeer)
  if (!has_addpeer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return addpeer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ADD_PEER::set_allocated_addpeer(std::string* addpeer) {
  if (addpeer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  addpeer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addpeer);
  // @@protoc_insertion_point(field_set_allocated:SFPacketStore.ADD_PEER.addpeer)
}

// -------------------------------------------------------------------

// DELETE_PEER

// required int32 serial = 1;
inline bool DELETE_PEER::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DELETE_PEER::clear_serial() {
  serial_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DELETE_PEER::serial() const {
  // @@protoc_insertion_point(field_get:SFPacketStore.DELETE_PEER.serial)
  return serial_;
}
inline void DELETE_PEER::set_serial(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  serial_ = value;
  // @@protoc_insertion_point(field_set:SFPacketStore.DELETE_PEER.serial)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SFPacketStore

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SFPacketStore::TeamType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SFPacketStore::TeamType>() {
  return ::SFPacketStore::TeamType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SFPacketStore_2eproto
